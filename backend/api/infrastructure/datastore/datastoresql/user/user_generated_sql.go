// Code generated by gen-go-datastore-sql. DO NOT EDIT.

package user

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"time"

	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"

	"github.com/Mire0726/safe_travel/backend/api/domain/model"
	"github.com/Mire0726/safe_travel/backend/api/domain/repository"
)

type client interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

type user struct {
	dbClient client
	logger   *log.Logger
}

func NewUser(dbClient client, logger *log.Logger) repository.User {
	return &user{
		dbClient: dbClient,
		logger:   logger,
	}
}

func (m *user) Get(ctx context.Context, id string, opt ...qm.QueryMod) (*model.User, error) {
	query := make([]qm.QueryMod, 0, len(opt)+2)
	query = append(query, qm.Where("id = ?", id), qm.And("deleted_at IS NULL"))
	query = append(query, opt...)

	m.logger.Printf("Will exec User.Get, package: sql")

	user, err := model.Users(
		query...,
	).One(ctx, m.dbClient)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("not found user: %w", err)
		}

		return nil, fmt.Errorf("error executing user.Get: %w", err)
	}

	return user, nil
}

func (u *user) BatchGet(ctx context.Context, ids []any, opt ...qm.QueryMod) (model.UserSlice, error) {
	query := make([]qm.QueryMod, 0, len(opt)+2)
	query = append(query, qm.WhereIn("id IN ?", ids...), qm.And("deleted_at IS NULL"))
	query = append(query, opt...)

	u.logger.Printf("Will exec User.BatchGet, package: sql")

	users, err := model.Users(
		query...,
	).All(ctx, u.dbClient)
	if err != nil {
		return nil, fmt.Errorf("error executing user.BatchGet: %w", err)
	}

	return users, nil
}

func (m *user) Count(ctx context.Context, opt ...qm.QueryMod) (int64, error) {
	query := make([]qm.QueryMod, 0, len(opt)+1)
	query = append(query, qm.Where("deleted_at IS NULL"))
	query = append(query, opt...)

	m.logger.Printf("Will execute User.Count, package: sql")

	count, err := model.Users(
		query...,
	).Count(ctx, m.dbClient)
	if err != nil {
		return 0, fmt.Errorf("error executing user.Count: %w", err)
	}

	return count, nil
}

func (m *user) List(ctx context.Context, opt ...qm.QueryMod) (model.UserSlice, error) {
	query := make([]qm.QueryMod, 0, len(opt)+1)
	query = append(query, qm.Where("deleted_at IS NULL"))
	query = append(query, opt...)

	m.logger.Printf("Will execute User.List, package: sql")

	users, err := model.Users(
		query...,
	).All(ctx, m.dbClient)
	if err != nil {
		return nil, fmt.Errorf("error executing user.List: %w", err)
	}

	return users, nil
}

func (m *user) Insert(ctx context.Context, user *model.User) error {
	m.logger.Printf("Will execute User.Insert, package: sql")

	err := user.Insert(ctx, m.dbClient, boil.Infer())
	if err != nil {
		return fmt.Errorf("error executing user.Insert: %w", err)
	}

	return nil
}

func (u *user) Delete(ctx context.Context, id string) error {
	u.logger.Printf("Will execute User.Delete, package: sql")

	const query = `UPDATE users SET deleted_at = $1 WHERE id = $2`

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
	}

	_, err := u.dbClient.ExecContext(
		ctx,
		query,
		time.Now(),
		id,
	)
	if err != nil {
		return fmt.Errorf("error executing user.Delete: %w", err)
	}

	return nil
}

func (u *user) BulkDelete(ctx context.Context, ids []any) error {
	if len(ids) == 0 {
		return nil
	}

	u.logger.Printf("Will execute User.BulkDelete, package: sql")

	const query = `UPDATE users SET deleted_at = $1 WHERE id IN (?)`

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
	}

	_, err := u.dbClient.ExecContext(
		ctx,
		query,
		time.Now(),
		ids,
	)
	if err != nil {
		return fmt.Errorf("error executing user.BulkDelete: %w", err)
	}

	return nil
}
