// Code generated by gen-go-datastore-sql. DO NOT EDIT.

package transport

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"time"

	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"

	"github.com/Mire0726/safe_travel/backend/api/domain/model"
	"github.com/Mire0726/safe_travel/backend/api/domain/repository"
)
type client interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

type transport struct {
	dbClient client
	logger   *log.Logger
}

func NewTransport(dbClient client, logger *log.Logger) repository.Transport {
	return &transport{
		dbClient: dbClient,
		logger:   logger,
	}
}

func (m *transport) Get(ctx context.Context, id string, opt ...qm.QueryMod) (*model.Transport, error) {
	query := make([]qm.QueryMod, 0, len(opt)+2)
	query = append(query, qm.Where("id = ?", id), qm.And("deleted_at IS NULL"))
	query = append(query, opt...)

	m.logger.Printf("Will exec Transport.Get, package: sql")

	transport, err := model.Transports(
		query...,
	).One(ctx, m.dbClient)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("not found transport: %w", err)
		}

		return nil, fmt.Errorf("error executing transport.Get: %w", err)
	}

	return transport, nil
}

func (u *transport) BatchGet(ctx context.Context, ids []any, opt ...qm.QueryMod) (model.TransportSlice, error) {
	query := make([]qm.QueryMod, 0, len(opt)+2)
	query = append(query, qm.WhereIn("id IN ?", ids...), qm.And("deleted_at IS NULL"))
	query = append(query, opt...)

	u.logger.Printf("Will exec Transport.BatchGet, package: sql")

	transports, err := model.Transports(
		query...,
	).All(ctx, u.dbClient)
	if err != nil {
		return nil, fmt.Errorf("error executing transport.BatchGet: %w", err)
	}

	return transports, nil
}

func (m *transport) Count(ctx context.Context, opt ...qm.QueryMod) (int64, error) {
	query := make([]qm.QueryMod, 0, len(opt)+1)
	query = append(query, qm.Where("deleted_at IS NULL"))
	query = append(query, opt...)

	m.logger.Printf("Will execute Transport.Count, package: sql")

	count, err := model.Transports(
		query...,
	).Count(ctx, m.dbClient)
	if err != nil {
		return 0, fmt.Errorf("error executing transport.Count: %w", err)
	}

	return count, nil
}

func (m *transport) List(ctx context.Context, opt ...qm.QueryMod) (model.TransportSlice, error) {
	query := make([]qm.QueryMod, 0, len(opt)+1)
	query = append(query, qm.Where("deleted_at IS NULL"))
	query = append(query, opt...)

	m.logger.Printf("Will execute Transport.List, package: sql")

	transports, err := model.Transports(
		query...,
	).All(ctx, m.dbClient)
	if err != nil {
		return nil, fmt.Errorf("error executing transport.List: %w", err)
	}

	return transports, nil
}

func (m *transport) Insert(ctx context.Context, transport *model.Transport) error {
	m.logger.Printf("Will execute Transport.Insert, package: sql")

	err := transport.Insert(ctx, m.dbClient, boil.Infer())
	if err != nil {
		return fmt.Errorf("error executing transport.Insert: %w", err)
	}

	return nil
}

func (u *transport) Delete(ctx context.Context, id string) error {
	u.logger.Printf("Will execute Transport.Delete, package: sql")

	const query = `UPDATE transports SET deleted_at = $1 WHERE id = $2`

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
	}

	_, err := u.dbClient.ExecContext(
		ctx,
		query,
		time.Now(),
		id,
	)
	if err != nil {
		return fmt.Errorf("error executing transport.Delete: %w", err)
	}

	return nil
}

func (u *transport) BulkDelete(ctx context.Context, ids []any) error {
	if len(ids) == 0 {
		return nil
	}

	u.logger.Printf("Will execute Transport.BulkDelete, package: sql")

	const query = `UPDATE transports SET deleted_at = $1 WHERE id IN (?)`

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
	}

	_, err := u.dbClient.ExecContext(
		ctx,
		query,
		time.Now(),
		ids,
	)
	if err != nil {
		return fmt.Errorf("error executing transport.BulkDelete: %w", err)
	}

	return nil
}
